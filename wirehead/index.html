<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wirehead - Cutting through the AI static</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#84cc16">
    <meta name="description" content="Cutting through the AI static">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <!-- SEO Meta Tags -->
    <meta name="author" content="Wirehead">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">
    <link rel="canonical" href="./">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Wirehead">
    <meta property="og:title" content="Wirehead - Cutting through the AI static">
    <meta property="og:description" content="Cutting through the AI static">
    <meta property="og:url" content="./">
    <meta property="og:image" content="./icon-192.png">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Wirehead - Cutting through the AI static">
    <meta name="twitter:description" content="Cutting through the AI static">
    <meta name="twitter:image" content="./icon-192.png">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Blog",
        "name": "Wirehead",
        "description": "Cutting through the AI static",
        "url": "https://wirehead.blog/",
        "author": {
            "@type": "Organization",
            "name": "Wirehead"
        },
        "publisher": {
            "@type": "Organization",
            "name": "Wirehead",
            "logo": {
                "@type": "ImageObject",
                "url": "https://wirehead.blog/icon-192.png"
            }
        }
    }
    </script>
    
    <style>
        /* Local Material Icons */
        @font-face {
            font-family: 'Material Icons';
            font-style: normal;
            font-weight: 400;
            src: url('./lib/material-icons.woff2') format('woff2');
        }

        .material-icons {
            font-family: 'Material Icons';
            font-weight: normal;
            font-style: normal;
            font-size: 24px;
            line-height: 1;
            letter-spacing: normal;
            text-transform: none;
            display: inline-block;
            white-space: nowrap;
            word-wrap: normal;
            direction: ltr;
            font-feature-settings: 'liga';
            -webkit-font-feature-settings: 'liga';
            -webkit-font-smoothing: antialiased;
        }

        /* Local Roboto Font */
        @font-face {
            font-family: 'Roboto';
            font-style: normal;
            font-weight: 300;
            src: url('./lib/roboto-300.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Roboto';
            font-style: normal;
            font-weight: 400;
            src: url('./lib/roboto-regular.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Roboto';
            font-style: normal;
            font-weight: 500;
            src: url('./lib/roboto-500.woff2') format('woff2');
        }

        @font-face {
            font-family: 'Roboto';
            font-style: normal;
            font-weight: 700;
            src: url('./lib/roboto-700.woff2') format('woff2');
        }

        /* Roboto Condensed for headings */
        @font-face {
            font-family: 'Roboto Condensed';
            font-style: normal;
            font-weight: 400;
            src: url('./lib/roboto-condensed-regular.woff2') format('woff2');
        }
        :root {
            --primary-color: #84cc16;
            --primary-variant: #65a30d;
            --secondary-color: #84cc16;
            --background: #f8f9fa;
            --surface: #ffffff;
            --surface-variant: #fffffff0;
            --app-bar-bg: #fffffff0;
            --error: #dc2626;
            --on-primary: #ffffff;
            --on-secondary: #000000;
            --on-background: #1f2937;
            --on-surface: #1f2937;
            --on-surface-variant: #6b7280;
            --on-error: #ffffff;
            --border: #e5e7eb;
            --border-variant: #d1d5db;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --primary-color: #a3e635;
                --primary-variant: #84cc16;
                --secondary-color: #a3e635;
                --background: #0f172a;
                --surface: #1e293b;
                --surface-variant: #000000f0;
                --app-bar-bg: #000000f0;
                --error: #ef4444;
                --on-primary: #0f172a;
                --on-secondary: #0f172a;
                --on-background: #f1f5f9;
                --on-surface: #f1f5f9;
                --on-surface-variant: #94a3b8;
                --on-error: #ffffff;
                --border: #475569;
                --border-variant: #64748b;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--background);
            color: var(--on-background);
            line-height: 1.6;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Roboto Condensed', 'Roboto', sans-serif;
            font-weight: 600;
        }

        .app-bar {
            background-color: var(--app-bar-bg);
            color: var(--on-surface);
            padding: 16px 24px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .app-bar .brand {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .app-bar .brand-icon {
            width: 32px;
            height: 32px;
            flex-shrink: 0;
        }

        .app-bar h1 {
            font-family: 'Roboto Condensed', 'Roboto', sans-serif;
            font-size: 24px;
            font-weight: 600;
            letter-spacing: -1px;
            margin: 0;
        }

        .app-bar h1, .app-bar .subtitle {
            display: inline-block;
        }

        .app-bar .subtitle {
            opacity: 0.75;
            font-weight: 400;
            margin-left: 2px;
        }

        .search-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-input {
            background-color: var(--surface);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 8px 40px 8px 16px;
            color: var(--on-surface);
            font-size: 14px;
            width: 200px;
            outline: none;
            transition: border-color 0.2s ease;
        }

        .search-input::placeholder {
            color: var(--on-surface-variant);
        }

        .search-input:focus {
            border-color: var(--primary-color);
        }

        .search-icon {
            position: absolute;
            right: 12px;
            color: var(--on-surface-variant);
            cursor: pointer;
            font-size: 20px;
            transition: color 0.2s ease;
        }

        .search-icon:hover {
            color: var(--primary-color);
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 24px;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 48px;
            font-size: 16px;
            color: var(--on-background);
        }

        .loading .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--primary-color);
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 12px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .post-card {
            background-color: var(--surface);
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid var(--border);
            margin-bottom: 16px;
            scroll-margin-top: 96px; /* keep title visible below sticky app bar */
        }

        .post-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .post-header {
            padding: 16px 24px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .post-info {
            flex: 1;
        }

        .post-title {
            font-family: 'Roboto Condensed', 'Roboto', sans-serif;
            font-size: 18px;
            font-weight: 400;
            margin-bottom: 4px;
            color: var(--on-surface);
        }

        .post-meta {
            font-size: 14px;
            color: var(--on-surface);
            opacity: 0.7;
        }

        .expand-icon {
            color: var(--on-surface);
            transition: transform 0.2s ease;
        }

        .expand-icon.expanded {
            transform: rotate(180deg);
        }

        .post-content {
            padding: 0 24px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .post-content.expanded {
            max-height: none;
            padding: 24px;
        }

        .post-content .markdown-content {
            color: var(--on-surface);
        }

        .post-content h1, .post-content h2, .post-content h3,
        .post-content h4, .post-content h5, .post-content h6 {
            margin: 16px 0 8px 0;
            color: var(--on-surface);
        }

        .post-content p {
            margin-bottom: 16px;
        }

        .post-content pre {
            background-color: rgba(0,0,0,0.05);
            padding: 16px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 16px 0;
        }

        @media (prefers-color-scheme: dark) {
            .post-content pre {
                background-color: rgba(255,255,255,0.05);
            }
        }

        .post-content code {
            background-color: rgba(0,0,0,0.05);
            padding: 2px 4px;
            border-radius: 2px;
            font-family: 'Courier New', monospace;
        }

        @media (prefers-color-scheme: dark) {
            .post-content code {
                background-color: rgba(255,255,255,0.05);
            }
        }

        .post-content blockquote {
            border-left: 4px solid var(--primary-color);
            padding-left: 16px;
            margin: 16px 0;
            font-style: italic;
        }

        .post-content ul, .post-content ol {
            padding-left: 24px;
            margin-bottom: 16px;
        }

        .error {
            background-color: var(--error);
            color: var(--on-error);
            padding: 16px;
            border-radius: 4px;
            margin: 16px 0;
        }

        .search-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .search-dialog.show {
            display: flex;
        }

        .search-dialog-content {
            background-color: var(--surface);
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }

        .search-dialog h2 {
            margin: 0 0 16px 0;
            color: var(--on-surface);
            font-size: 20px;
            font-weight: 500;
        }

        .search-dialog p {
            margin: 0 0 16px 0;
            color: var(--on-surface);
            line-height: 1.5;
        }

        .search-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 24px;
        }

        .search-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-option:hover {
            background-color: var(--surface-variant);
            border-color: var(--primary-color);
        }

        .search-option input[type="radio"] {
            margin: 0;
        }

        .search-option-content {
            flex: 1;
        }

        .search-option-title {
            font-weight: 500;
            color: var(--on-surface);
            margin-bottom: 4px;
        }

        .search-option-description {
            font-size: 14px;
            color: var(--on-surface);
            opacity: 0.7;
        }

        .search-dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .search-dialog-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }

        .search-dialog-button.primary {
            background-color: var(--primary-color);
            color: var(--on-primary);
        }

        .search-dialog-button.primary:hover {
            background-color: var(--primary-variant);
        }

        .search-dialog-button.secondary {
            background-color: transparent;
            color: var(--on-surface);
            border: 1px solid var(--border);
        }

        .search-dialog-button.secondary:hover {
            background-color: var(--surface-variant);
            border-color: var(--primary-color);
        }

        @media (max-width: 600px) {
            .container {
                padding: 16px;
            }
            
            .app-bar {
                padding: 16px;
                flex-direction: column;
                gap: 12px;
            }
            
            .search-container {
                width: 100%;
                justify-content: center;
            }
            
            .search-input {
                width: 250px;
            }
            
            .post-header {
                padding: 16px;
            }
            
            .post-content.expanded {
                padding: 16px;
            }
            
            .search-dialog-content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="app-bar">
        <div class="brand">
            <img src="icon.svg" alt="Wirehead" class="brand-icon">
            <div>
                <h1>Wirehead</h1>
            <h1><div class="subtitle">Cutting through the AI static</div></h1>
            </div>
        </div>
        <div class="search-container">
            <input type="text" class="search-input" placeholder="Search articles..." id="search-input">
            <span class="material-icons search-icon" id="search-button">search</span>
        </div>
    </div>

    <div class="container">
        <div id="loading" class="loading">
            <div class="spinner"></div>
            Loading posts...
        </div>
        <div id="posts-container"></div>
        <div id="error-container"></div>
    </div>

    <!-- Search Dialog -->
    <div class="search-dialog" id="search-dialog">
        <div class="search-dialog-content">
            <h2>Search Articles</h2>
            <p>Choose your search scope:</p>
            
            <div class="search-options">
                <label class="search-option" for="search-loaded">
                    <input type="radio" id="search-loaded" name="search-scope" value="loaded" checked>
                    <div class="search-option-content">
                        <div class="search-option-title">Search loaded articles only</div>
                        <div class="search-option-description" id="loaded-count">Search through articles you've already viewed (faster)</div>
                    </div>
                </label>
                
                <label class="search-option" for="search-all">
                    <input type="radio" id="search-all" name="search-scope" value="all">
                    <div class="search-option-content">
                        <div class="search-option-title">Search all articles</div>
                        <div class="search-option-description" id="all-count">Load and search through all available articles</div>
                    </div>
                </label>
            </div>
            
            <div class="search-dialog-buttons">
                <button class="search-dialog-button secondary" id="search-cancel">Cancel</button>
                <button class="search-dialog-button primary" id="search-proceed">Search</button>
            </div>
        </div>
    </div>

    <script src="./lib/marked.min.js"></script>
    <script>
        class WireheadBlog {
            constructor() {
                this.posts = [];
                this.expandedPosts = new Set();
                this.db = null;
                this.currentSearchQuery = '';
                this.currentArticleSlug = null;
                this.init();
            }

            async init() {
                try {
                    await this.initDatabase();
                    await this.loadPosts();
                    await this.loadCachedContent();
                    this.renderPosts();
                    this.setupRouting();
                    this.handleInitialRoute();
                    this.setupSearchHandlers();
                } catch (error) {
                    this.showError('Failed to load blog posts: ' + error.message);
                } finally {
                    this.hideLoading();
                }
            }

            async initDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('WireheadBlog', 1);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('articles')) {
                            const store = db.createObjectStore('articles', { keyPath: 'file' });
                            store.createIndex('title', 'title', { unique: false });
                            store.createIndex('date', 'date', { unique: false });
                        }
                    };
                });
            }

            async loadPosts() {
                const response = await fetch('posts.json');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                
                // Convert filename array to post objects with extracted data
                this.posts = data.posts.map(filename => ({
                    file: filename,
                    title: this.extractTitleFromFilename(filename),
                    date: this.extractDateFromFilename(filename)
                }));
                
                // Sort posts by date (newest first)
                this.posts.sort((a, b) => new Date(b.date) - new Date(a.date));
            }

            async loadCachedContent() {
                if (!this.db) return;
                
                const transaction = this.db.transaction(['articles'], 'readonly');
                const store = transaction.objectStore('articles');
                
                for (const post of this.posts) {
                    try {
                        const cached = await new Promise((resolve, reject) => {
                            const request = store.get(post.file);
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                        
                        if (cached) {
                            post.content = cached.content;
                            post.cachedTitle = cached.title;
                            // Update title from cached content if available
                            if (cached.title && cached.title !== post.title) {
                                post.title = cached.title;
                            }
                        }
                    } catch (error) {
                        console.warn(`Failed to load cached content for ${post.file}:`, error);
                    }
                }
            }

            setupRouting() {
                // Handle browser back/forward buttons
                window.addEventListener('popstate', (e) => {
                    this.handleRouteChange();
                });
            }

            handleInitialRoute() {
                const urlParams = new URLSearchParams(window.location.search);
                const postParam = urlParams.get('post');
                
                if (postParam) {
                    const slug = postParam.replace(/\.md$/i, '');
                    this.navigateToArticle(slug, false);
                } else {
                    // Default behavior - expand first two posts
                    this.autoExpandFirstTwo();
                }
            }

            handleRouteChange() {
                const urlParams = new URLSearchParams(window.location.search);
                const postParam = urlParams.get('post');
                
                if (postParam) {
                    const slug = postParam.replace(/\.md$/i, '');
                    this.navigateToArticle(slug, false);
                } else {
                    this.currentArticleSlug = null;
                    this.updatePageMeta();
                }
            }

            getArticleSlug(filename) {
                return filename.replace('.md', '');
            }

            navigateToArticle(slug, updateHistory = true) {
                const postIndex = this.posts.findIndex(post => this.getArticleSlug(post.file) === slug);
                
                if (postIndex !== -1) {
                    this.currentArticleSlug = slug;
                    
                    // Collapse all other posts
                    this.expandedPosts.clear();
                    
                    // Expand the target post
                    this.togglePost(postIndex, false);
                    
                    // Update URL if needed
                    if (updateHistory) {
                        const url = `?post=${slug}`;
                        window.history.pushState({ slug }, '', url);
                    }
                    
                    // Update page metadata
                    this.updatePageMeta(this.posts[postIndex]);
                    
                    // Scroll to post
                    setTimeout(() => {
                        const postElement = document.querySelector(`#post-${slug}`);
                        if (postElement) {
                            postElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 100);
                }
            }

            updatePageMeta(post = null) {
                if (post) {
                    document.title = `${post.title} - Wirehead`;
                    
                    // Update meta description
                    let description = 'Cutting through the AI static';
                    if (post.content) {
                        // Extract first paragraph as description
                        const firstParagraph = post.content.split('\n\n')[1] || post.content.split('\n')[2];
                        if (firstParagraph && firstParagraph.length > 10) {
                            description = firstParagraph.replace(/[#*`]/g, '').substring(0, 160) + '...';
                        }
                    }
                    
                    this.updateMetaTag('description', description);
                    this.updateMetaTag('og:title', `${post.title} - Wirehead`);
                    this.updateMetaTag('og:description', description);
                    const slug = this.getArticleSlug(post.file);
                    this.updateMetaTag('og:url', `${window.location.origin}/?post=${slug}`);
                    this.updateMetaTag('og:type', 'article');
                    
                    // Update canonical URL
                    this.updateCanonicalUrl(`${window.location.origin}/?post=${slug}`);
                    
                    // Add structured data for the article
                    this.updateStructuredData(this.generateArticleStructuredData(post));
                } else {
                    document.title = 'Wirehead - Cutting through the AI static';
                    this.updateMetaTag('description', 'Cutting through the AI static');
                    this.updateMetaTag('og:title', 'Wirehead - Cutting through the AI static');
                    this.updateMetaTag('og:description', 'Cutting through the AI static');
                    this.updateMetaTag('og:url', window.location.origin);
                    this.updateMetaTag('og:type', 'website');
                    
                    // Update canonical URL
                    this.updateCanonicalUrl(window.location.origin);
                    
                    // Remove article structured data
                    this.removeStructuredData('article-structured-data');
                }
            }

            updateCanonicalUrl(url) {
                let canonical = document.querySelector('link[rel="canonical"]');
                if (!canonical) {
                    canonical = document.createElement('link');
                    canonical.setAttribute('rel', 'canonical');
                    document.head.appendChild(canonical);
                }
                canonical.setAttribute('href', url);
            }

            updateStructuredData(data) {
                // Remove existing article structured data
                this.removeStructuredData('article-structured-data');
                
                // Add new structured data
                const script = document.createElement('script');
                script.type = 'application/ld+json';
                script.id = 'article-structured-data';
                script.textContent = JSON.stringify(data);
                document.head.appendChild(script);
            }

            removeStructuredData(id) {
                const existing = document.getElementById(id);
                if (existing) {
                    existing.remove();
                }
            }

            updateMetaTag(name, content) {
                let meta = document.querySelector(`meta[name="${name}"], meta[property="${name}"]`);
                if (!meta) {
                    meta = document.createElement('meta');
                    if (name.startsWith('og:')) {
                        meta.setAttribute('property', name);
                    } else {
                        meta.setAttribute('name', name);
                    }
                    document.head.appendChild(meta);
                }
                meta.setAttribute('content', content);
            }

            setupSearchHandlers() {
                const searchButton = document.getElementById('search-button');
                const searchInput = document.getElementById('search-input');
                const searchDialog = document.getElementById('search-dialog');
                const searchCancel = document.getElementById('search-cancel');
                const searchProceed = document.getElementById('search-proceed');
                
                searchButton.addEventListener('click', () => this.showSearchDialog());
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.showSearchDialog();
                    }
                });
                
                searchCancel.addEventListener('click', () => this.hideSearchDialog());
                searchProceed.addEventListener('click', () => this.executeSearch());
                
                // Close dialog when clicking outside
                searchDialog.addEventListener('click', (e) => {
                    if (e.target === searchDialog) {
                        this.hideSearchDialog();
                    }
                });
            }

            renderPosts() {
                const container = document.getElementById('posts-container');
                container.innerHTML = '';

                this.posts.forEach((post, index) => {
                    const postElement = this.createPostElement(post, index);
                    container.appendChild(postElement);
                });
            }

            createPostElement(post, index) {
                const slug = this.getArticleSlug(post.file);
                const postDiv = document.createElement('div');
                postDiv.className = 'post-card';
                postDiv.id = `post-${slug}`;
                postDiv.innerHTML = `
                    <div class="post-header" onclick="blog.togglePost(${index})">
                        <div class="post-info">
                            <div class="post-title">${this.escapeHtml(post.title)}</div>
                            <div class="post-meta">${this.formatDate(post.date)}</div>
                        </div>
                        <span class="material-icons expand-icon" id="icon-${index}">expand_more</span>
                    </div>
                    <div class="post-content" id="content-${index}">
                        <div class="markdown-content" id="markdown-${index}"></div>
                    </div>
                `;
                return postDiv;
            }

            async togglePost(index, updateUrl = true) {
                const post = this.posts[index];
                const contentElement = document.getElementById(`content-${index}`);
                const iconElement = document.getElementById(`icon-${index}`);
                const markdownElement = document.getElementById(`markdown-${index}`);

                if (this.expandedPosts.has(index)) {
                    // Collapse
                    contentElement.classList.remove('expanded');
                    iconElement.classList.remove('expanded');
                    this.expandedPosts.delete(index);
                    
                    // Update URL to home if this was the current article
                    if (updateUrl && this.currentArticleSlug === this.getArticleSlug(post.file)) {
                        this.currentArticleSlug = null;
                        window.history.pushState({}, '', window.location.pathname);
                        this.updatePageMeta();
                    }
                } else {
                    // Expand
                    try {
                        if (!markdownElement.innerHTML.trim()) {
                            markdownElement.innerHTML = '<div class="loading"><div class="spinner"></div>Loading content...</div>';
                        }
                        
                        contentElement.classList.add('expanded');
                        iconElement.classList.add('expanded');
                        this.expandedPosts.add(index);

                        // Load markdown content if not already loaded
                        if (!post.content) {
                            const response = await fetch(`posts/${post.file}`);
                            if (!response.ok) {
                                throw new Error(`Failed to load ${post.file}`);
                            }
                            post.content = await response.text();
                        }

                        // Extract title from first heading and remove it from content
                        const { title, content } = this.extractTitleFromMarkdown(post.content);
                        
                        // Update post title if we found one in the markdown
                        if (title) {
                            post.title = title;
                            // Update the title in the UI
                            const titleElement = document.querySelector(`#posts-container .post-card:nth-child(${index + 1}) .post-title`);
                            if (titleElement) {
                                titleElement.textContent = title;
                            }
                        }

                        // Cache the article in IndexedDB
                        await this.cacheArticle(post);

                        // Render markdown to HTML (with first heading removed)
                        const htmlContent = marked.parse(content);
                        markdownElement.innerHTML = htmlContent;
                        
                        // Update URL and metadata if this is a user-initiated action
                        if (updateUrl) {
                            this.navigateToArticle(this.getArticleSlug(post.file), true);
                        }
                    } catch (error) {
                        markdownElement.innerHTML = `<div class="error">Error loading post: ${error.message}</div>`;
                    }
                }
            }

            autoExpandFirstTwo() {
                const firstThree = Math.min(2, this.posts.length);
                for (let i = 0; i < firstThree; i++) {
                    setTimeout(() => this.togglePost(i), i * 100);
                }
            }

            async cacheArticle(post) {
                if (!this.db || !post.content) return;
                
                try {
                    const transaction = this.db.transaction(['articles'], 'readwrite');
                    const store = transaction.objectStore('articles');
                    
                    const articleData = {
                        file: post.file,
                        title: post.title,
                        content: post.content,
                        date: post.date,
                        cachedAt: new Date().toISOString()
                    };
                    
                    await new Promise((resolve, reject) => {
                        const request = store.put(articleData);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.warn(`Failed to cache article ${post.file}:`, error);
                }
            }

            showSearchDialog() {
                const query = document.getElementById('search-input').value.trim();
                if (!query) {
                    document.getElementById('search-input').focus();
                    return;
                }
                
                this.currentSearchQuery = query;
                
                // Update dialog counts
                const loadedCount = this.posts.filter(p => p.content).length;
                const totalCount = this.posts.length;
                
                document.getElementById('loaded-count').textContent = 
                    `Search through ${loadedCount} articles you've already viewed (faster)`;
                document.getElementById('all-count').textContent = 
                    `Load and search through all ${totalCount} articles (${totalCount - loadedCount} will be loaded)`;
                
                document.getElementById('search-dialog').classList.add('show');
            }

            hideSearchDialog() {
                document.getElementById('search-dialog').classList.remove('show');
            }

            async executeSearch() {
                const scope = document.querySelector('input[name="search-scope"]:checked').value;
                this.hideSearchDialog();
                
                if (scope === 'all') {
                    await this.loadAllArticles();
                }
                
                this.performSearch(this.currentSearchQuery, scope);
            }

            async loadAllArticles() {
                const unloadedPosts = this.posts.filter(p => !p.content);
                
                if (unloadedPosts.length === 0) return;
                
                // Show loading indicator
                const container = document.getElementById('posts-container');
                const loadingDiv = document.createElement('div');
                loadingDiv.className = 'loading';
                loadingDiv.innerHTML = `
                    <div class="spinner"></div>
                    Loading ${unloadedPosts.length} articles for search...
                `;
                container.insertBefore(loadingDiv, container.firstChild);
                
                try {
                    for (const post of unloadedPosts) {
                        const response = await fetch(`posts/${post.file}`);
                        if (response.ok) {
                            post.content = await response.text();
                            
                            // Extract title and cache
                            const { title } = this.extractTitleFromMarkdown(post.content);
                            if (title) {
                                post.title = title;
                            }
                            
                            await this.cacheArticle(post);
                        }
                    }
                    
                    // Update UI with new titles
                    this.renderPosts();
                } finally {
                    loadingDiv.remove();
                }
            }

            performSearch(query, scope) {
                const searchTerms = query.toLowerCase().split(' ').filter(term => term.length > 0);
                const postsToSearch = scope === 'loaded' 
                    ? this.posts.filter(p => p.content)
                    : this.posts;
                
                const results = [];
                
                for (const post of postsToSearch) {
                    const titleMatch = searchTerms.some(term => 
                        post.title.toLowerCase().includes(term)
                    );
                    
                    let contentMatch = false;
                    if (post.content) {
                        contentMatch = searchTerms.some(term => 
                            post.content.toLowerCase().includes(term)
                        );
                    }
                    
                    if (titleMatch || contentMatch) {
                        results.push({
                            post,
                            titleMatch,
                            contentMatch
                        });
                    }
                }
                
                this.displaySearchResults(results, query);
            }

            displaySearchResults(results, query) {
                const container = document.getElementById('posts-container');
                
                if (results.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 48px; color: var(--on-background); opacity: 0.7;">
                            <h3>No results found</h3>
                            <p>No articles match your search for "${this.escapeHtml(query)}"</p>
                            <button onclick="blog.clearSearch()" style="margin-top: 16px; padding: 8px 16px; background: var(--primary-color); color: var(--on-primary); border: none; border-radius: 4px; cursor: pointer;">Show all articles</button>
                        </div>
                    `;
                    return;
                }
                
                // Show search results header
                const header = document.createElement('div');
                header.style.cssText = 'margin-bottom: 24px; padding: 16px; background: var(--surface); border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);';
                header.innerHTML = `
                    <h3 style="margin: 0 0 8px 0; color: var(--on-surface);">Search Results</h3>
                    <p style="margin: 0; color: var(--on-surface); opacity: 0.7;">Found ${results.length} article${results.length !== 1 ? 's' : ''} matching "${this.escapeHtml(query)}"</p>
                    <button onclick="blog.clearSearch()" style="margin-top: 12px; padding: 6px 12px; background: transparent; color: var(--primary-color); border: 1px solid var(--primary-color); border-radius: 4px; cursor: pointer; font-size: 14px;">Clear search</button>
                `;
                
                container.innerHTML = '';
                container.appendChild(header);
                
                // Show filtered posts
                const filteredPosts = results.map(r => r.post);
                this.posts = [...filteredPosts]; // Temporarily replace posts for rendering
                
                results.forEach((result, index) => {
                    const postElement = this.createPostElement(result.post, index);
                    container.appendChild(postElement);
                });
            }

            clearSearch() {
                // Restore original posts and re-render
                this.loadPosts().then(() => {
                    this.loadCachedContent().then(() => {
                        this.renderPosts();
                    });
                });
                
                // Clear search input
                document.getElementById('search-input').value = '';
            }

            // Generate dynamic sitemap for search engines
            generateSitemap() {
                const currentDate = new Date().toISOString().split('T')[0];
                
                let sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
    <url>
        <loc>/</loc>
        <lastmod>${currentDate}</lastmod>
        <changefreq>weekly</changefreq>
        <priority>1.0</priority>
    </url>`;

                this.posts.forEach(post => {
                    const slug = this.getArticleSlug(post.file);
                    const lastmod = post.date || currentDate;
                    sitemap += `
    <url>
        <loc>/?post=${slug}</loc>
        <lastmod>${lastmod}</lastmod>
        <changefreq>monthly</changefreq>
        <priority>0.9</priority>
    </url>`;
                });

                sitemap += `
</urlset>`;
                
                return sitemap;
            }

            // Generate structured data for individual articles
            generateArticleStructuredData(post) {
                const baseUrl = window.location.origin;
                const slug = this.getArticleSlug(post.file);
                
                return {
                    "@context": "https://schema.org",
                    "@type": "BlogPosting",
                    "headline": post.title,
                    "description": post.content ? 
                        post.content.split('\n\n')[1]?.replace(/[#*`]/g, '').substring(0, 160) + '...' :
                        'Cutting through the AI static',
                    "url": `${baseUrl}/?post=${slug}`,
                    "datePublished": post.date,
                    "dateModified": post.date,
                    "author": {
                        "@type": "Organization",
                        "name": "Wirehead"
                    },
                    "publisher": {
                        "@type": "Organization",
                        "name": "Wirehead",
                        "logo": {
                            "@type": "ImageObject",
                            "url": `${baseUrl}/icon-192.png`
                        }
                    },
                    "mainEntityOfPage": {
                        "@type": "WebPage",
                        "@id": `${baseUrl}/?post=${slug}`
                    }
                };
            }

            extractTitleFromFilename(filename) {
                // Extract title from filename after date: YYYY-MM-DD-title.md or YYYY-MM-title.md
                const titleMatch = filename.match(/^\d{4}-\d{2}(?:-\d{2})?-(.+)\.md$/);
                
                if (!titleMatch) {
                    // Fallback to filename without extension
                    return filename.replace(/\.md$/, '');
                }
                
                // Convert dashes to spaces and title case each word
                return titleMatch[1]
                    .split('-')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                    .join(' ');
            }

            extractTitleFromMarkdown(markdownContent) {
                // Find the first heading (# Title)
                const lines = markdownContent.split('\n');
                let title = null;
                let contentLines = [...lines];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.startsWith('# ')) {
                        title = line.substring(2).trim();
                        // Remove this line from content
                        contentLines.splice(i, 1);
                        break;
                    }
                    // Stop looking if we hit non-empty content that's not a heading
                    if (line && !line.startsWith('#')) {
                        break;
                    }
                }
                
                return {
                    title: title,
                    content: contentLines.join('\n')
                };
            }

            extractDateFromFilename(filename) {
                // Extract date from filename format: YYYY-MM-DD or YYYY-MM
                const dateMatch = filename.match(/^(\d{4})-(\d{2})(?:-(\d{2}))?/);
                
                if (!dateMatch) {
                    // Fallback to current date if no match
                    return new Date().toISOString().split('T')[0];
                }
                
                const year = parseInt(dateMatch[1]);
                const month = parseInt(dateMatch[2]);
                let day = dateMatch[3] ? parseInt(dateMatch[3]) : null;
                
                // If no day specified, use the last day of the month
                if (!day) {
                    // Create date with first day of next month, then subtract 1 day
                    const lastDayOfMonth = new Date(year, month, 0).getDate();
                    day = lastDayOfMonth;
                }
                
                // Create date string in YYYY-MM-DD format
                const dateString = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                return dateString;
            }

            formatDate(dateString) {
                const date = new Date(dateString);
                return date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            showError(message) {
                const errorContainer = document.getElementById('error-container');
                errorContainer.innerHTML = `<div class="error">${this.escapeHtml(message)}</div>`;
            }

            hideLoading() {
                const loading = document.getElementById('loading');
                loading.style.display = 'none';
            }
        }

        // Initialize the blog
        const blog = new WireheadBlog();

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('SW registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }
    </script>
</body>
</html>
