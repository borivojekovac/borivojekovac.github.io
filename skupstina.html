<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skupština i Takovska uživo</title>
  <style>
    :root {
      --padding: 20px;
      --gap: 20px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background-color: #1a1a1a;
      color: #fff;
      padding: var(--padding);
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    #video-container {
      display: flex;
      gap: var(--gap);
      margin-bottom: 100px;
      flex-direction: row;
    }

    @media (orientation: portrait) {
      #video-container {
        flex-direction: column;
      }
    }

    .stream-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .stream-wrapper h2 {
      margin-bottom: 10px;
      font-size: 1.2em;
    }

    .stream-display {
      width: 100%;
      aspect-ratio: 704 / 567;
      background-color: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .stream-display img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .stream-display.loading::after {
      content: 'Loading...';
      color: #666;
      position: absolute;
    }

    #timeline-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: var(--padding);
      background-color: rgba(42, 42, 42, 0.9);
      backdrop-filter: blur(10px);
      z-index: 1000;
    }

    .timeline-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #history-mode {
      background-color: #1a1a1a;
      color: #fff;
      border: 1px solid #444;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      min-width: 100px;
    }

    #history-mode:hover {
      border-color: #666;
    }

    #timeline-slider {
      flex: 1;
      height: 40px;
      cursor: pointer;
    }

    #timeline-label {
      font-size: 0.9em;
      color: #aaa;
      min-width: 90px;
      text-align: right;
      white-space: nowrap;
    }

  </style>
</head>
<body>
  <div id="video-container">
    <div class="stream-wrapper">
      <h2>Trg Nikole Pašića</h2>
      <div id="stream1" class="stream-display loading"></div>
    </div>
    <div class="stream-wrapper">
      <h2>Takovska</h2>
      <div id="stream2" class="stream-display loading"></div>
    </div>
  </div>

  <div id="timeline-container">
    <div class="timeline-controls">
      <select id="history-mode">
        <option value="low">~250 kadrova</option>
        <option value="med" selected>~500 kadrova</option>
        <option value="high">~1000 kadrova</option>
      </select>
      <input type="range" id="timeline-slider" min="0" max="1000" value="1000" step="1">
      <div id="timeline-label">Nema snimaka</div>
    </div>
  </div>

  <script>
    class VideoStreamManager {
      constructor(baseUrl, containerElement, streamName) {
        this.baseUrl = baseUrl;
        this.containerElement = containerElement;
        this.streamName = streamName;
        this.history = [];
        this.targetFPS = 1;
        this.nativeWidth = 704;
        this.nativeHeight = 567;
        this.isViewingLive = true;
        this.currentDisplayedImage = null;
        this.fetchStartTime = null;
        this.isActive = false;
        this.pruningInterval = null;
        this.onNewFrame = null; // Callback for timeline updates
        // Load history mode from localStorage or default to 'med'
        this.historyMode = localStorage.getItem('historyMode') || 'med';
        this.historyZones = this.getHistoryZones();
      }

      getHistoryZones() {
        const zones = {
          high: [
            { duration: 120000,    targetFPS: 1.0 },
            { duration: 240000,    targetFPS: 0.5 },
            { duration: 480000,    targetFPS: 0.25 },
            { duration: 960000,    targetFPS: 0.125 },
            { duration: 1800000,   targetFPS: 0.0667 },
            { duration: 3600000,   targetFPS: 0.0333 },
            { duration: 7200000,   targetFPS: 0.0167 },
            { duration: 14400000,  targetFPS: 0.0083 },
            { duration: 28800000,  targetFPS: 0.0042 },
            { duration: Infinity,  targetFPS: 0.0021 }
          ],
          med: [
            { duration: 120000,    targetFPS: 1.0 },
            { duration: 240000,    targetFPS: 0.5 },
            { duration: 480000,    targetFPS: 0.2 },
            { duration: 1800000,   targetFPS: 0.05 },
            { duration: 7200000,   targetFPS: 0.0125 },
            { duration: 28800000,  targetFPS: 0.003125 },
            { duration: Infinity,  targetFPS: 0.00078 }
          ],
          low: [
            { duration: 60000,     targetFPS: 1.0 },
            { duration: 180000,    targetFPS: 0.333 },
            { duration: 900000,    targetFPS: 0.0667 },
            { duration: 5400000,   targetFPS: 0.0111 },
            { duration: 28800000,  targetFPS: 0.0021 },
            { duration: Infinity,  targetFPS: 0.0004 }
          ]
        };
        return zones[this.historyMode];
      }

      setHistoryMode(mode) {
        this.historyMode = mode;
        this.historyZones = this.getHistoryZones();
        localStorage.setItem('historyMode', mode);
        this.pruneHistory();
      }

      start() {
        if (this.isActive) return;
        this.isActive = true;
        this.isViewingLive = true;
        this.fetchNextFrame();
        
        // Schedule pruning every 60 seconds
        this.pruningInterval = setInterval(() => {
          this.pruneHistory();
        }, 60000);
      }

      stop() {
        this.isActive = false;
        if (this.pruningInterval) {
          clearInterval(this.pruningInterval);
          this.pruningInterval = null;
        }
      }

      fetchNextFrame() {
        if (!this.isActive) return;

        this.fetchStartTime = Date.now();
        const img = new Image();
        const uniq = Math.random();
        
        img.onload = () => {
          const timestamp = Date.now();
          this.history.push({ timestamp, imageElement: img });
          
          // Trim history if needed
          if (this.history.length > this.maxHistorySize) {
            this.history.shift();
          }

          // Display if viewing live
          if (this.isViewingLive) {
            this.displayLatest();
          }

          // Notify timeline controller
          if (this.onNewFrame) {
            this.onNewFrame();
          }

          // Schedule next fetch
          this.scheduleNextFetch();
        };

        img.onerror = () => {
          // Just retry on next interval
          this.scheduleNextFetch();
        };

        img.src = `${this.baseUrl}?uniq=${uniq}`;
      }

      scheduleNextFetch() {
        if (!this.isActive) return;

        const elapsed = Date.now() - this.fetchStartTime;
        const targetInterval = 1000 / this.targetFPS; // 1000ms for 1 FPS
        const nextInterval = Math.ceil(elapsed / targetInterval) * targetInterval;
        const delay = nextInterval - elapsed;
        
        setTimeout(() => this.fetchNextFrame(), delay);
      }

      displayFrame(targetTimestamp) {
        if (this.history.length === 0) return;

        this.isViewingLive = false;

        // Find closest frame
        let closestFrame = this.history[0];
        let minDiff = Math.abs(this.history[0].timestamp - targetTimestamp);

        for (let i = 1; i < this.history.length; i++) {
          const diff = Math.abs(this.history[i].timestamp - targetTimestamp);
          if (diff < minDiff) {
            minDiff = diff;
            closestFrame = this.history[i];
          }
        }

        // Display the frame
        this.swapImage(closestFrame.imageElement);
      }

      displayLatest() {
        if (this.history.length === 0) return;
        
        this.isViewingLive = true;
        const latest = this.history[this.history.length - 1];
        this.swapImage(latest.imageElement);
      }

      swapImage(newImage) {
        // Remove loading class
        this.containerElement.classList.remove('loading');

        // Remove previous image
        if (this.currentDisplayedImage && this.currentDisplayedImage.parentNode === this.containerElement) {
          this.containerElement.removeChild(this.currentDisplayedImage);
        }

        // Add new image
        this.containerElement.appendChild(newImage);
        this.currentDisplayedImage = newImage;
      }

      getOldestTimestamp() {
        return this.history.length > 0 ? this.history[0].timestamp : null;
      }

      getLatestTimestamp() {
        return this.history.length > 0 ? this.history[this.history.length - 1].timestamp : null;
      }

      pruneHistory() {
        if (this.history.length < 2) return;
        
        const now = this.history[this.history.length - 1].timestamp;
        const keepFrames = [this.history[0]]; // Always keep first
        
        for (let i = 1; i < this.history.length; i++) {
          const frame = this.history[i];
          const age = now - frame.timestamp;
          const zone = this.getZoneForAge(age);
          const minInterval = 1000 / zone.targetFPS;
          
          const lastKept = keepFrames[keepFrames.length - 1];
          const timeSinceLastKept = frame.timestamp - lastKept.timestamp;
          
          // Keep if it's the last frame OR sufficient time has passed
          if (i === this.history.length - 1 || timeSinceLastKept >= minInterval) {
            keepFrames.push(frame);
          }
        }
        
        this.history = keepFrames;
      }

      getZoneForAge(age) {
        let cumulative = 0;
        for (let zone of this.historyZones) {
          cumulative += zone.duration;
          if (age < cumulative || zone.duration === Infinity) {
            return zone;
          }
        }
        return this.historyZones[this.historyZones.length - 1];
      }
    }

    class TimelineController {
      constructor(streams, sliderElement, labelElement, historyModeElement) {
        this.streams = streams;
        this.sliderElement = sliderElement;
        this.labelElement = labelElement;
        this.historyModeElement = historyModeElement;
        this.lastUpdateTime = 0;
        this.updateThrottle = 1000; // 1 second
        this.isDragging = false;
        this.oldestTimestamp = null;
        this.newestTimestamp = null;
        this.exponent = 3; // Exponential curve strength

        // Bind events
        this.sliderElement.addEventListener('input', () => this.onSliderChange());
        this.sliderElement.addEventListener('mousedown', () => this.isDragging = true);
        this.sliderElement.addEventListener('mouseup', () => this.isDragging = false);
        this.sliderElement.addEventListener('touchstart', () => this.isDragging = true);
        this.sliderElement.addEventListener('touchend', () => this.isDragging = false);

        // History mode change
        this.historyModeElement.addEventListener('change', () => this.onHistoryModeChange());

        // Set callbacks for streams
        this.streams.forEach(stream => {
          stream.onNewFrame = () => this.onNewFrame();
        });
      }

      onNewFrame() {
        const now = Date.now();
        if (now - this.lastUpdateTime < this.updateThrottle) {
          return; // Throttle updates
        }
        this.lastUpdateTime = now;
        this.updateSlider();
      }

      updateSlider() {
        // Find oldest and newest timestamps across all streams
        let oldestTimestamp = null;
        let newestTimestamp = null;

        this.streams.forEach(stream => {
          const oldest = stream.getOldestTimestamp();
          const newest = stream.getLatestTimestamp();

          if (oldest !== null && (oldestTimestamp === null || oldest < oldestTimestamp)) {
            oldestTimestamp = oldest;
          }
          if (newest !== null && (newestTimestamp === null || newest > newestTimestamp)) {
            newestTimestamp = newest;
          }
        });

        if (oldestTimestamp === null || newestTimestamp === null) {
          return; // No frames yet
        }

        const wasAtNow = this.isAtNow();
        const currentTimestamp = this.sliderValueToTimestamp(parseInt(this.sliderElement.value));

        this.oldestTimestamp = oldestTimestamp;
        this.newestTimestamp = newestTimestamp;

        // Update value intelligently
        if (wasAtNow) {
          // Keep at now
          this.sliderElement.value = 1000;
        } else {
          // Maintain the same timestamp with new mapping
          const newValue = this.timestampToSliderValue(currentTimestamp);
          this.sliderElement.value = newValue;
        }

        this.updateLabel();
      }

      onSliderChange() {
        const targetTimestamp = this.sliderValueToTimestamp(parseInt(this.sliderElement.value));
        const isAtNow = this.isAtNow();

        this.streams.forEach(stream => {
          if (isAtNow) {
            stream.isViewingLive = true;
            stream.displayLatest();
          } else {
            stream.displayFrame(targetTimestamp);
          }
        });

        this.updateLabel();
      }

      onHistoryModeChange() {
        const mode = this.historyModeElement.value;
        this.streams.forEach(stream => {
          stream.setHistoryMode(mode);
        });
        this.updateSlider();
      }

      isAtNow() {
        return this.sliderElement.value >= 999;
      }

      sliderValueToTimestamp(value) {
        if (this.oldestTimestamp === null || this.newestTimestamp === null) {
          return Date.now();
        }
        
        // Map 0-1000 to timestamp range with exponential curve
        const progress = value / 1000;
        const exponentialProgress = Math.pow(progress, this.exponent);
        
        const timestamp = this.oldestTimestamp + 
          (this.newestTimestamp - this.oldestTimestamp) * exponentialProgress;
        
        return timestamp;
      }

      timestampToSliderValue(timestamp) {
        if (this.oldestTimestamp === null || this.newestTimestamp === null) {
          return 1000;
        }
        
        const range = this.newestTimestamp - this.oldestTimestamp;
        if (range === 0) return 1000;
        
        const linearProgress = (timestamp - this.oldestTimestamp) / range;
        const value = Math.pow(linearProgress, 1 / this.exponent) * 1000;
        
        return Math.max(0, Math.min(1000, value));
      }

      updateLabel() {
        if (this.oldestTimestamp === null || this.newestTimestamp === null) {
          this.labelElement.textContent = '';
          return;
        }

        const timestamp = this.sliderValueToTimestamp(parseInt(this.sliderElement.value));
        const date = new Date(timestamp);
        const timeString = date.toLocaleTimeString();
        const isLive = this.isAtNow();
        
        this.labelElement.textContent = isLive ? timeString : `(${timeString})`;
      }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      const stream1 = new VideoStreamManager(
        'https://stream.uzivobeograd.rs/live/cam_20.jpg',
        document.getElementById('stream1'),
        'Trg Nikole Pašića'
      );

      const stream2 = new VideoStreamManager(
        'https://stream.uzivobeograd.rs/live/cam_13.jpg',
        document.getElementById('stream2'),
        'Takovska'
      );

      // Restore saved history mode
      const savedMode = localStorage.getItem('historyMode') || 'med';
      document.getElementById('history-mode').value = savedMode;

      const timeline = new TimelineController(
        [stream1, stream2],
        document.getElementById('timeline-slider'),
        document.getElementById('timeline-label'),
        document.getElementById('history-mode')
      );

      // Start both streams
      stream1.start();
      stream2.start();
    });
  </script>
</body>
</html>